# data <- readExtractedMocapData(path="~/Dropbox/mocap/gripStudy/analysis/extractedData/")

# take a string of formulas to try, and iterate over them. (does lapply work sequentially?)

# Fit an lmer model with an equation and data, return list of the model, and convergence diagnostics (with the equation as the name)
fitLMERsingle <- function(eq, data){
  oldWarn <- getOption("warn") # save the old warning state
  options(warn = -1) # ignore all warnings

  fitOut <- lme4::lmer(stats::as.formula(eq), data)
  convLme4 <- fitOut@optinfo$conv$lme4
  if(is.list(convLme4) & length(convLme4) != 0){
    # check if the lme4 convergence list has any contents
    warnCode <- convLme4$code
    warnMessages <- convLme4$messages
  } else {
    # if the lme4 convergence list has no contents, setup success variables
    warnCode <- 0
    warnMessages <- ""
  }

  options(warn = oldWarn) # ignore all warnings
  return(list(modelObject=fitOut, converged={warnCode==0}, convWarnCode=warnCode, convWarnMsgs=warnMessages))
}

# Vectorized version of fitLMERsingle
fitLMER <- Vectorize(fitLMERsingle, vectorize.args = "eq", SIMPLIFY = FALSE)

# generate equations (formulas) with two predictors from maximal to simpler
eqsGen2preds <- function(outcome, predictor1, predictor2, grouping1 = "obsisSubj"){
  eqs <- character()
  eqs <- append(eqs, paste0(outcome, "~", predictor1, "*", predictor2, "+", "(", "1+", predictor1, "*", predictor2, "|", grouping1, ")"))
  eqs <- append(eqs, paste0(outcome, "~", predictor1, "*", predictor2, "+", "(", "1+", predictor1, "+", predictor2, "|", grouping1, ")"))
  eqs <- append(eqs, paste0(outcome, "~", predictor1, "+", predictor2, "+", "(", "1+", predictor1, "+", predictor2, "|", grouping1, ")"))
  return(eqs)
}


#' Fit the right models based on the name of the dataset being passed
#'
#' @param type this is the type of data that is going to be analyzed from \code{data}. Examples: "action", "estimation" The name of this option determines which model will be fit.
#' @param data a data object as generated by \code{\link{readExtractedMocapData}}
#' @param additionalModelTypes additional types of models that are not currently programed (this may change.)
#' @return a list of fit models
#'
fitModels <- function(type, data, additionalModelTypes=list()){

  # should these be stored as json for possible external editing?
  modelsByType <- list(
    "action" = list("outcome" = "maxGrip",
                      "predictor1" = "stickcmScaled",
                      "predictor2" = "fins"),
    "estimation" = list("outcome" = "meanGrip",
                    "predictor1" = "stickcmScaled",
                    "predictor2" = "fins")
  )
  # add additional models, a bit of a hack for expansion?
  if(length(additionalModelTypes)>0){
    modelsByType <- c(modelsByType, additionalModelTypes)
  }

  # check if the type of analysis is one of the known ones.
  # update this message if the models by type is moved elsewhere.
  if(!{type %in% names(modelsByType)}){
    stop("Error, the type ", type, " can't be found in the models by type specification for what variables to use. Please update the modelsByType to include this model type.", sep="")
  }

  modelsOut <- fitLMER(eqsGen2preds(outcome=modelsByType[[type]]$outcome,
                                    predictor1=modelsByType[[type]]$predictor1,
                                    predictor2=modelsByType[[type]]$predictor2)
                       , data=data[[type]]$data)

  return(modelsOut)
}

#' Pick one model as the best
#'
#' \code{findTheBestModel} finds the first (by default) model in a list that does not have convergence errors. As the formula lists are configured now, this will return the most complex model (that does not have convergence errors). This does not run any model comparison, it just finds the first (or last if specified with option \code{last=TRUE})
#'
#' @param models A list of models, as generated by \code{\link{fitModels}}
#' @param last A logical, should the last model be picked? By default this is \code{FALSE}, which means the first model will be picked.
#' @return Returns a list of length two, the first, named \code{chosenModel} is the model chosen, \code{allModels} has all of the models, and is a copy of \code{models}
#'
findTheBestModel <- function(models, last = FALSE){

  if(last){
    modName <- names(which.max(which(unlist(lapply(models, function(x) x$converged)))))
  } else {
    modName <- names(which.min(which(unlist(lapply(models, function(x) x$converged)))))
  }
  bestModel <- list(models[[modName]])
  names(bestModel) <- modName

  return(list("bestModel" = bestModel, "allModels" = models))
}


#' Pick one model as the bist
#'
#' takes data, and returns an object that includes the originional data as well as fit models.
#'
#' @param data A list of data, as generated by \code{\link{readExtractedMocapData}}
#' @param ... options to pass to \code{\link{fitModels}} (or \code{\link{findTheBestModel}}, if reprogrammed adjusted)
#' @return Returns a list very similar to the \code{data} that also includes a \code{models} list with each set of data within \code{data} (except for \code{allData}, if it is present.)
#'
#' @export
modelAllData <- function(data, ...){
  analyses<- names(data)

  for (analysis in analyses){
    models <- fitModels(analysis, data)
    modelsProced <- findTheBestModel(models, ...)
    data[[analysis]][["models"]] <- modelsProced
  }
  return(data)
}

