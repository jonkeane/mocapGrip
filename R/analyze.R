
# Fit an lmer model with an equation and data, return list of the model, and convergence diagnostics (with the equation as the name)
fitLMERsingle <- function(eq, data){
  oldWarn <- getOption("warn") # save the old warning state
  options(warn = -1) # ignore all warnings

  fitOut <- lme4::lmer(stats::as.formula(eq), data)
  convLme4 <- fitOut@optinfo$conv$lme4
  if(is.list(convLme4) & length(convLme4) != 0){
    # check if the lme4 convergence list has any contents
    warnCode <- convLme4$code
    warnMessages <- convLme4$messages
  } else {
    # if the lme4 convergence list has no contents, setup success variables
    warnCode <- 0
    warnMessages <- ""
  }

  options(warn = oldWarn) # ignore all warnings
  return(list(modelObject=fitOut, converged={warnCode==0}, convWarnCode=warnCode, convWarnMsgs=warnMessages))
}

# Vectorized version of fitLMERsingle
fitLMER <- Vectorize(fitLMERsingle, vectorize.args = "eq", SIMPLIFY = FALSE)

# generate equations (formulas) with two predictors from maximal to simpler
# this is depricated, because eqsGen is a better use of modelMetadata.json
eqsGen2preds <- function(outcome, predictor1, predictor2, grouping1 = "obsisSubj"){
  eqs <- character()
  eqs <- append(eqs, paste0(outcome, "~", predictor1, "*", predictor2, "+", "(", "1+", predictor1, "*", predictor2, "|", grouping1, ")"))
  eqs <- append(eqs, paste0(outcome, "~", predictor1, "*", predictor2, "+", "(", "1+", predictor1, "+", predictor2, "|", grouping1, ")"))
  eqs <- append(eqs, paste0(outcome, "~", predictor1, "+", predictor2, "+", "(", "1+", predictor1, "+", predictor2, "|", grouping1, ")"))
  return(eqs)
}

# generate equations from variables to use and formulas (both of which come from modelMetadata.json)
eqsGen <- Vectorize(function(variablesToUse, formula){
  with(variablesToUse, eval(parse(text=formula)))
}, vectorize.args = "formula", USE.NAMES = TRUE)


#' Fit the right models based on the name of the dataset being passed
#'
#' @param dataSet this is the data set to use. Exampls: "action", "estimation"
#' @param analysis this is the analysis of data that is going to be analyzed from \code{data}. Examples: "maxGrip.stickAsContinuous", "meanGrip.stickAsContinuous" The name of this option determines which model will be fit.
#' @param data a data object as generated by \code{\link{readExtractedMocapData}}
#' @return a list of fit models
#'
fitModels <- function(dataSet, analysis, data){

  # check if the analysis of analysis is one of the known ones.
  # update this message if the models by analysis is moved elsewhere.
  if(!{analysis %in% names(modelMetadata$models$analyses)}){
    stop("Error, the analysis ", analysis, " can't be found in the analyses specifications that are available. Please update the modelMetadata object or modelMetadata.json", sep="")
  }

  modelsOut <- fitLMER(eqsGen(modelMetadata$models$analyses[[analysis]]$variablesToUse,
                                    modelMetadata$models$modelStructures)
                       , data=data[[dataSet]]$data)

  return(modelsOut)
}

#' Pick one model as the best
#'
#' \code{findTheBestModel} finds the first (by default) model in a list that does not have convergence errors. As the formula lists are configured now, this will return the most complex model (that does not have convergence errors). This does not run any model comparison, it just finds the first (or last if specified with option \code{last=TRUE})
#'
#' @param models A list of models, as generated by \code{\link{fitModels}}
#' @param last A logical, should the last model be picked? By default this is \code{FALSE}, which means the first model will be picked.
#' @return Returns a list of length two, the first, named \code{chosenModel} is the model chosen, \code{allModels} has all of the models, and is a copy of \code{models}
#'
findTheBestModel <- function(models, last = FALSE){

  # check that at least one model converged?

  if(last){
    modName <- names(which.max(which(unlist(lapply(models, function(x) x$converged)))))
  } else {
    modName <- names(which.min(which(unlist(lapply(models, function(x) x$converged)))))
  }
  bestModel <- list(models[[modName]])
  names(bestModel) <- modName

  return(list("bestModel" = bestModel, "allModels" = models))
}


#' Pick one model as the bist
#'
#' takes data, and returns an object that includes the originional data as well as fit models.
#'
#' @param data A list of data, as generated by \code{\link{readExtractedMocapData}}
#' @param ... options to pass to \code{\link{fitModels}} (or \code{\link{findTheBestModel}}, if reprogrammed adjusted)
#' @return Returns a list very similar to the \code{data} that also includes a \code{models} list with each set of data within \code{data} (except for \code{allData}, if it is present.)
#'
#' @export
modelAllData <- function(data, ...){
  dataSets <- names(data)

  # exclude full data if present
  dataSets <- dataSets[dataSets!="fullData"]

  for (dataSet in dataSets){
    analyses <- data[[dataSet]]$analysesToRun
    if(length(analyses)<1){
      warning("There are no analyses in analysesToRun for the dataSet ", dataSet, " so no analyses were run for that data set.", sep="")
    } else{
      data[[dataSet]][["analyses"]] <- list()
    }
    for(analysis in analyses){
      models <- fitModels(dataSet=dataSet, analysis=analysis, data=data)
      modelsProced <- findTheBestModel(models, ...)
      data[[dataSet]][["analyses"]][[analysis]] <- modelsProced
    }

  }
  return(data)
}

